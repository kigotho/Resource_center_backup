<!DOCTYPE html>
<html class="article" lang="en"><head>
    <meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" utf-8"="">
<meta name="viewport" content="width=device-width, minimum-scale=1.0">
<meta name="Description" content="Neurogami: Engage your world. Feed your head. Hack your world. Live curious. Custom game and application development for Leap Motion, Xbox Kinect, and Wii controllers.">
<meta name="keywords" content="Arizona, Phoenix, Scottsdale, Neurogami, Neurogami Agency, Web, Leap Motion, Wii, game development, desktop, Arduino, Android, hardware, HCI, Kinect, software, James Britt">

    <title>Neurogami: 10 Minutes to Your First Ruby Application</title>
    <!-- COMMON STUFF -->
<!-- link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Anton" -->

<script async="" src="on_files/analytics.js"></script><script type="text/javascript" src="on_files/jquery.js"></script>
<script type="text/javascript" src="on_files/styleswitcher.js"></script>

<style>

@font-face {
  font-family: 'Anton';
  font-style: normal;
  font-weight: normal;
  src: local('Anton'), url('/static/fonts/anton/v3/tilmJBBU81h1G7ZsdY3Hmw.woff') format('woff');
}

</style>

    <meta name="google-site-verification" content="fI1pfSn-zMsjeI5VFwxPX_BIw76_SSua4fRaMsGVJbk">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="on_files/grid.css">
    <link rel="stylesheet" href="on_files/keywords.css">
    <link id="css" rel="stylesheet" title="default" href="on_files/style.css">
    <link id="cssmono" rel="alternate stylesheet" title="mono" href="on_files/mono.css">
    <link rel="stylesheet" href="on_files/switch.css">
    <link rel="stylesheet" href="on_files/common.css">
    <link rel="shortcut icon" href="http://neurogami.com/icon.png">
    <link rel="faveicon" href="http://neurogami.com/icon.png">
    <link rel="apple-touch-icon-precomposed" href="http://neurogami.com/icon.png">
    <link rel="alternate" type="application/atom+xml" href="http://neurogami.com/feed/atom.xml" title="Atom 1.0">
    <link rel="sitemap" href="http://neurogami.com/sitemap.xml">

  </head>
  <body class="wrapper" itemscope="" itemtype="http://schema.org/Article" style="font-size: 112.8%;">

    <div class="grids" id="article">
      <div class="grid-12">
                

<div class="flush">
<ul class="flat-menu">

   <li><a href="http://neurogami.com/">Home</a></li>



   <li><a href="http://music.neurogami.com/">Music</a></li>



   <li><a href="http://neurogami.com/blog">Blog</a></li>




  <li><a href="http://neurogami.com/code">Software</a></li>

  

   <li><a href="http://neurogami.com/content">Articles</a></li>



   <li><a href="http://neurogami.com/about">About</a></li>


</ul>
</div>

        <h1 class="blog-title" itemprop="name">10 Minutes to Your First Ruby Application</h1>
        <div class="blog-date">2012-10-31 18:20:07 -0700</div>
      </div>

      <div class="grid-1">
        &nbsp;
      </div>

      <div class="grid-11">

        
<style type="text/css">
  .note {
    border: solid 2px #cc3300;
    padding: 10px;
    background-color: #FFFF00;

  }
  .whiteHeader {
    background-color: #dfdfdf;
  
    color: #FF0080; 
  }
  
    br { display:block; margin-top:10px; line-height:22px; }
  
</style>

    <div class="grids">
      <p>By James Britt</p>
      <div class="note">
        <p>2012-11: The code and article has been updated to fix some errors and to work with Ruby 1.9.3</p>
         <p>At the time it was written, and because of where it was 
originally published, it was targeted (more or less) at people working 
on Windows, so there may be a few unstated assumptions in the text.</p>
         <p>On the other hand, the command-line examples seem to reflect
 a unix shell, no doubt because that's where the bulk of the content was
 created.</p>
         <p>Apologies in advance for any confusion.</p>
      </div>

      <div class="abstract"><br>There's no better way to experience the 
elegance and power of Ruby than to fire up your code editor and start 
writing Ruby code. Create a small, useful Ruby application, and along 
the way, you'll learn what makes the language tick.</div>
      <br><br>
      So you've discovered the grace and power of Ruby and you're ready 
to explore the subtle but important ideas behind its elegance. Follow 
this tutorial to create a small, useful Ruby application. As Ruby is 
primarily an object-oriented language with classes and objects, you can 
jump right in and create a class to encapsulate behavior. The 
instructions begin with a simple version of the application, and then 
expand it. Along the way, you will learn what makes Ruby tick. 
      <br><br>
      The example application will serve two purposes:
      <ol>
        <li>Demonstrate some features of Ruby</li>
        <li>Do something useful in the process</li>
      </ol>
      <br><br>
      A word on the title: Were you to write this code yourself, 
assuming some moderate Ruby knowledge, it probably wouldn't take more 
than 10 minutes. Once you learn how Ruby works and understand what sort 
of code it enables, you'll find that you can whip up useful utilities in
 short order. Of course, a walk-through of such code will take a bit 
more than 10 minutes if you're new to the language.
      <br>
      <br>
      <div align="center">
        <table frame="box" rules="rows" cellspacing="2" cellpadding="2" width="50%" border="1">
          <tbody><tr>
            <th align="center">What You Need</th>
          </tr>
          <tr>
            <td> This tutorial assumes that you already have a current 
version of Ruby installed, and you have a code editor handy. You don't 
need a fancy IDE to code in Ruby; Vim, Emacs, and TextMate are great 
choices. NetBeans and Eclipse work fine as well.</td>
          </tr>
        </tbody></table>
      </div>
      <br>
      <h2>Target Problem: Simplifying File Launching</h2>
      Ruby is primarily a text-based, command-line-oriented language. 
Some GUI libraries are available, as well as multiple Web application 
frameworks, but exploring GUI development with Ruby is beyond the scope 
this article. The goal here is to write something that works from the 
command line.
      <br the="" example="" task="" is="" simplifying="" file="" launching.="" given="" a="" text="" (maybe="" ruby="" source="" code="" file),="" suppose="" you="" want="" to="" create="" way="" launch="" it="" in="" some="" associated="" application="" from="" command="" line.="" and="" without="" having="" keep="" track="" of="" types="" associations.="" yes,="" windows="" (and="" other="" operating="" systems)="" already="" does="" this,="" but="" your="" will="" have="" additional="" features="" that="" go="" beyond="" this="" simple="" behavior.="" <br=""><br>
      <h3>Version 0: The Launcher Code</h3>
      First, create a sparse Ruby file. Ruby files end with <code>.rb</code> and have the pivotal line that defines the path to your Ruby interpreter up top. Call the file <code>launcher.rb</code>:
<pre><code>
     #!/usr/bin/env ruby

     # Example application to demonstrate some basic Ruby features
     # This code loads a given file into an associated application

      class Launcher
      end
</code></pre>
      <br>
      Notice you can use a pound sign (#) to start a line-level comment.
 Everything to the right of the # is hidden from the interpreter. Ruby 
has a means for commenting multiple lines of code, too. Class names 
begin with a capital letter; classes are constants, and all Ruby 
constants start with a capital letter. (For a more complete overview of 
Ruby syntax, please see "Ruby—A Diamond of a Programming Language?", <a href="http://www.devx.com/enterprise/Article/30917/" target="new">Part 1</a> and <a href="http://www.devx.com/enterprise/Article/31197" target="new">Part 2</a>.)
      <br><br>
      While this code seemingly does nothing, it is executable. If 
you're playing along at home, you should see that your copy of the code 
executes. A simple way to run a Ruby script is to simply call the ruby 
interpreter and pass the name of the file, like this (see <a href="http://neurogami.com/content/neurogami-10_minutes_to_your_first_Ruby_app/sidebar1.html" name="ref1" id="ref1">Sidebar 1. Instructions for Executing launcher.rb in Unix and Windows</a>): 

<pre><code>
$ ruby launcher.rb
</code></pre>
      <br>
      When you run the file, you should see nothing—unless there's an 
error of some sort in the code. So, nothing is good. It doesn't mean 
nothing is happening; when the ruby interpreter parses your file, it 
encounters your class definition and makes it available for creating 
objects. The following code adds the class definition to your code:
<pre><code>
     #!/usr/bin/env ruby

     # Example application to demonstrate some basic Ruby features
     # This code loads a given file into an associated application

      class Launcher
      end

     launcher = Launcher.new
</code></pre>
      <br>
      The code first creates a variable (<code>launcher</code>) that is 
assigned a reference to a new instance of the class Launcher. You do not
 have to declare the type of the variable. Ruby uses strong, dynamic 
typing, and variables can hold references to objects of any type. Pretty
 much everything in Ruby is an object, including strings, numbers, and 
regular expressions. Each of these has a formal creation method (e.g., <code>String.new</code>), but Ruby tries to make it easy and fluid to work with the common cases.
      <br><br>
      Second, Ruby creates the object instance by invoking <code>new</code> on your Launcher class. <code>New</code>
 is a class method; it's analogous to constructor methods in Java. Of 
course, an empty object won't get you far, so you must add some 
behavior.
      <br><br>
      <i>Adding Behavior</i><br><br>
      The essence of your application takes a given file name and passes
 it to an associated application for processing of some sort. The 
launcher code will need to know how to do this mapping, so when you 
create an instance of a Launcher class, you must pass in some sort of 
mapping. You've seen that you can use the class method <code>new</code> to create an instance of a class. To create an instance that starts life with some set of data, you can pass in arguments to <code>new</code>. To handle this, you of course will have to add some code to Launcher:
<pre><code>
  def initialize app_map 
    @app_map = app_map
  end
</code></pre>
      <br>

      You define methods in Ruby using the <code>def</code> keyword, 
followed by the method name, and then the augment list, if any. The 
argument list is in parentheses for clarity, though Ruby will allow you 
to omit them when the meaning of the code is unambiguous (see <a href="#sidebar2" name="ref2" id="ref2">Sidebar 2. Why You Add initialize Method When Passing Arguments to <code>new</code> Method</a>).
      <br><br>
      It's worth noting then that Ruby objects begin life with assorted 
built-in behavior. You can use these as is, or opt to override them.
      <br><br>
      <i>Instance Variables</i><br><br>
      Your initialize method takes one argument, <code>app_map</code>. 
Again, as with the earlier variable, you do not give the types of method
 arguments. You just say that the method takes one argument (<code>app_map</code>), and in the body of the method this argument gets assigned to the variable <code>@app_map</code>. The <span class="icode">@</span>
 symbol indicates that the variable is an instance variable (i.e., it is
 available to all the code in this object). You create this instance 
variable when you create your object, and it will be available to any 
other methods you add to your code.
      <br><br>
      To have your application execute a given file using the associated application, drop some more code into it:
<pre><code>
class Launcher

  def initialize app_map 
    @app_map = app_map
  end

  # Execute the given file using the associate app
  def run file_name 
    application = select_app file_name 
    system "#{application} #{file_name}" 
  end

  # Given a file, look up the matching application
  def select_app file_name 
    ftype = file_type file_name 
    @app_map[ ftype ]
  end

  # Return the part of the file name string after the last '.'
  def file_type file_name 
    File.extname( file_name ).gsub( /^\./, '' ).downcase 
  end

end
</code></pre>
      <br><br>
      The method <code>run</code> takes a file name as its argument, passes it to <code>select_app</code>
 to find out which application to execute, and then uses Ruby's system 
method to invoke that application, passing the file name. The <code>system</code> method simply kicks the given command into a sub-shell. While <code>select_app</code> takes the file name, calls <code>file_type</code> to get a 'normalized' file extension, and then uses that as a key into <code>@app_map</code> to see which application to run.
      <br><br>
      Finally, <code>file_type</code> takes the file name and uses a class method on Ruby's File class to get the extension. The string returned by <code>extname</code> includes the period (.) that precedes the file extension. You don't need that, so the code uses <code>gsub</code> (or global substitute) to strip it; it then converts what remains to all lowercase letters with <code>downcase</code>.
      <br><br>
      For compactness, all these method calls are chained together. The 
string returned from File.extname is the receiver of the <span class="icode">gsub</span> request; the string returned from <span class="icode">gsub</span> then becomes the receiver of the call to <span class="icode">downcase</span>.
      <br><br>
      The example code so far has used objects that you expect to be <span class="icode">String</span>s and <span class="icode">Hash</span>es,
 but what you really care about is that these objects will respond to 
particular messages in an appropriate way. (Before delving into how to 
call your shiny new object, see <a href="#sidebar3" name="ref3" id="ref3">Sidebar 3. A Few Words About Objects, Types, and Behavior</a>.)
 For such a small application, the subtlety and power of an object 
system based on messages and run-time behavior may not be critical, but 
it is important to understand this as you go on to write larger Ruby 
applications.
      <br><br>
      <h3>Rounding Out Version 0</h3>
      Finish up this first version by putting it to use. You can add the
 following code to the end of the file to create an instance of Launcher
 and use it to run an application:
<pre><code>
def help
  print " 
  You must pass in the path to the file to launch.

  Usage: #{__FILE__} target_file
" 
end

if ARGV.empty?
  help
  exit
end

app_map = {
 'html' =&gt; 'firefox',
 'rb' =&gt; 'gvim',
 'jpg' =&gt; 'gimp'
}

l = Launcher.new app_map 
target = ARGV.join ' ' 
l.run target 

</code></pre>

      <p>You can download this code <a href="http://neurogami.com/code/10-minutes/v0/launcher.rb">here</a>.</p>      
      <br>
      The method <span class="icode">help</span> will render instructions if needed. <span class="icode">ARGV</span>
 is the argument vector; it is a built-in Ruby object that holds all the
 parameters passed to your program. If it's empty, then your program has
 nothing to work with, so it displays the help and exits. Otherwise, it 
creates a hash object and assigns it to the variable <span class="icode">app_map</span>. 
      <br><br>
      The <span class="icode">{ ... }</span> notation is Ruby's literal syntax for creating a <span class="icode">Hash</span> object. You could have used <span class="icode">Hash.new</span>, but it's verbose. Using the literal notation, you map hash keys to values using <span class="icode">=&gt;</span>.
 The hash is used to populate your Launcher instance, while the 
command-line arguments are collected into a single string stored in the 
variable <span class="icode">target</span>, which is passed into <span class="icode">run</span>.
      <br><br>
      Before trying this code, you need to change the application values used in <span class="icode">app_map</span> so that they refer to the proper executable. Assuming you have "rb" mapped to a text editor, you can try the code like this:
<pre><code>
$ ruby launcher.rb launcher.rb
</code></pre>
      <br><br>
      This should open your source code in your editor.

      <br><br>

      <h2>Bulking Up to Version 1 with Dynamic Loading</h2>
      So far, so good with Version 0, but you can do better. Rather than
 having a simple, direct mapping of file types to the application, you 
could map file types to execution handlers. That is, you can define code
 for your file types that can then decide which application to run, and 
with which arguments, depending on additional command-line arguments.
      <br><br>
      For example, if you are doing web development and have created an 
HTML file, you most often want to view it in a browser. So your 
application as it is works OK. But sometimes you want to view it using a
 particular browser. Right now, Launcher only allows a single 
application association. What you may want is the ability to launch <span class="icode">myfile.html</span> in the Opera web browser:
<pre><code>
$ ./launcher myfile.html opera
</code></pre>
      <br>
      Or you my want to perform some syntax checking on the HTML:
<pre><code>
$ ./launcher myfile.html syntax
</code></pre>
      <br><br>
      In other words, you want to add some smarts (see <a href="#sidebar4" name="ref4" id="ref4">Sidebar 4. The Smarts Behind Launching Logic</a>).
      <br><br>
      <i>Dynamic Loading</i><br>
      To add those smarts, you will change your program so that you can 
associate file types with Ruby code rather than associating a particular
 application. That Ruby code will handle the launching logic, allowing 
you to decide just how clever to be when launching an application for a 
given file type (see <a href="#sidebar5" name="ref5" id="ref5">Sidebar 5. Dynamic Class Loading with Defined Custom Ruby Classes</a>).
      <br><br>
      Before doing this, make one small change. Having all your code in 
one place is handy, but it's not a good practice for anything but the 
smallest apps. For the sake of better organization, split out the 
general class code from the code that interacts with the user. Do this 
by creating a file, <span class="icode">go.rb</span>, and moving all but the actual Launcher code into that file (i.e, that last chunk of code you just added):
<pre><code>
#!/usr/bin/env ruby

require 'launcher'

# Script to invoke launcher using command-line args
def help
  print " 
  You must pass in the path to the file to launch.

  Usage: #{__FILE__} target_file
" 
end

unless ARGV.size &gt; 0
  help
  exit
end

app_map = {
   'html' =&gt; 'firefox',
   'txt' =&gt; 'gvim',
   'jpg' =&gt; 'gimp'
}

l = Launcher.new app_map 
target = ARGV.join ' ' 
l.run target 

</code></pre>
      <br>
      Note the extra line of code near the top:
<pre><code>
$:.unshift '.' 
require 'launcher'
</code></pre>
      <br>
      You need these line to make your Launcher available to the current script. 
      <br><br>
      [EDIT: Since Ruby 1.9, ruby does not automatically include the current directory on the require look-up path.  <span class="icode">$:.unshift '.'</span> takes the current folder and adds it to the statr of the array of places your ruby app will look for files to require.]
      <br><br>
      The <span class="icode">require</span> method looks for a file matching the given string. The file extension is omitted, so Ruby first will assume you want a <span class="icode">.rb</span> file but also will look for a compiled library (e.g., <span class="icode">.so</span>)
 if it doesn't find a Ruby file. (Ruby searches a pre-defined load-path,
 which includes the current directory, so if you keep launcher.rb in the
 same place as go.rb, you're good. If you move it, you have to be more 
explicit about were Ruby can find it.)
      <br><br>
     Downloads: <a href="http://neurogami.com/code/10-minutes/v1/go.rb">go.rb</a> and <a href="http://neurogami.com/code/10-minutes/v1/launcher.rb">launcher.rb</a>
      <br><br>

      <h3>Writing a Handler Class</h3>
      Now that you have a simple framework for routing file names to 
Ruby code, create a handler class for HTML files. The class needs to 
implement a <span class="icode">run</span> method that accepts at least 
one argument for the target file name, and an optional array of 
additional parameters. The class name must be Html in a file named <span class="icode">html.rb</span>, and placed in a <span class="icode">handlers</span> subdirectory:
<pre><code>
class Html

  DEFAULT_BROWSER = 'firefox'

  def run file, args
    if args.empty?
      system "#{DEFAULT_BROWSER} #{file}" 
    else
      dispatch_on_parameters file, args
    end
  end

  def dispatch_on_parameters file, args
    cmd = args.shift
    send "do_#{cmd}", file, args 
  end

  def do_opera file, args=nil
    system "opera #{file}  #{args}" 
  end

  def do_konq file, args=nil
    system "konqueror #{file}  #{args}" 
  end
end
</code></pre>
      <br>
      The code defines a constant for a default browser. In the absence 
of any extra arguments, then, you can have the target file launched in 
Firefox. (Note that you may have to change this so that it defines an 
executable command. On my Ubuntu machine I can run <span class="icode">firefox</span> with no explicit path and have a browser come up. On Windows, for example, the full path to the executable may be needed.)
      <br><br>
      If there are additional arguments, <span class="icode">run</span> calls out to <span class="icode">dispatch_on_parameters</span>, which extracts the first item from the args array and uses it to dynamically construct a message string. The <span class="icode">send</span>
 method is built in to all Ruby objects. It allows you to explicitly 
send a message to an object. When used by itself (as you are doing 
here), the receiver object is assumed to be the current object. So the 
code is sending a message to itself.
      <br><br>
      You prepend <span class="icode">do_</span> to the actual argument value as a safeguard against method name collision. (For example, if the first argument were <span class="icode">exit</span>, you probably would not want to invoke Ruby's <span class="icode">exit</span> method. You'd call <span class="icode">do_exit</span>, which would then decide what the correct behavior should be).
      <br><br>
      This handler code has some fairly trivial examples of possible 
parameter handling. As is, you can launch a target HTML file in either 
some default browser or specify a particular browser:
<pre><code>
$ ./go index.html opera
$ ./go index.html konq
</code></pre>
      <br>
      <h2>A Little Overtime for Coolness</h2>
      You've received an educational and practical example, but can you 
push things a little further? Of course you can. Mind you, this will 
take you past the 10-minute mark, but it should be worth it.
      <br><br>
      The standard Ruby distribution includes a wealth of libraries for 
all sorts of tasks. One of the most interesting is REXML, an XML parser 
written in pure Ruby. Developer Sean Russell wrote REXML to allow the 
manipulation of XML using a Ruby-style API rather than the usual W3C DOM
 API. Before too long, Sean's work became part of the Ruby standard 
library.
      <br><br>
      For the sake of simplicity, your HTML files in this example must 
use XHTML because REXML handles only XML. (There are very good Ruby 
tools for processing near-arbitrary HTML, one being <a href="http://code.whytheluckystiff.net/hpricot/" target="new">Hpricot</a>.
 However, they require installing additional libraries, the explanation 
of which is beyond the scope of this article.) Trusting that you are 
working with well-formed XHTML source, you can have your HTML handler do
 some file analysis. Add this code to the end of your <span class="icode">Html</span> class and you'll be able to run some simple reports on your XHTML:
<pre><code>
  def do_report file, args=nil 
    require 'rexml/document'
    begin 
      dom = REXML::Document.new( IO.read( file ) )
      if args.empty?
        puts basic_xhtml_report( dom )
      else
        puts report_on( dom, args.first )
      end
    rescue Exception
      warn "There was a problem reading '#{file}':\n#{$!}" 
    end
  end

  def report_on dom, element
    els =   dom.root.elements.to_a "//#{element}" 
    "The document has #{els.size} '#{element}' elements" 
  end

  def basic_xhtml_report dom  
    report = []
    css = dom.root.elements.to_a '//link[@rel="stylesheet"]' 
    unless css.empty?
      report &lt;&lt; "The file references #{css.size} stylesheets" 
      css.each do |el|
        file_name = el.attributes['href']
        file_name.gsub! /^\//, ''
        unless File.exist? file_name
          report &lt;&lt; "*** Cannot find stylesheet file '#{file_name}'" 
        end
      end
    end

    js = dom.root.elements.to_a '//script' 
    unless js.empty?
      report &lt;&lt; "The file references #{js.size} JavaScript files" 
      js.each do |el|
        file_name = el.attributes['src']
        file_name.gsub! /^\//, ''
        unless File.exist? file_name
          report &lt;&lt; "*** Cannot find JavaScript file '#{file_name}'" 
        end
      end
    end

    report.join "\n" 
  end
</code></pre>
      <br><br>
      There's a lot going on here, but the key method is <span class="icode">do_report</span>. The code creates a REXML <span class="icode">Document</span> object and assigns it to <span class="icode">dom</span>.
 If there are no extra arguments, you get back a basic report. 
Otherwise, the code does some cursory examination of a particular 
element.
      <br><br>
      The <span class="icode">report_on</span> method takes a document 
argument and an element name, and uses REXML's XPath features to find 
out how often that element is used. Although it's rudimentary, it 
certainly can serve as a demonstration and starting point for you to 
keep hacking.
      <br><br>
      The <span class="icode">basic_xhtml_report</span> method is 
similar, but focuses on a particular set of elements. It uses REXML to 
find all the CSS and JavaScript references, and then uses the File class
 to check that the referenced files exist. Again, not deep, but adding 
additional logic makes for a nice project.
      <br><br>
      You can download these files from <a href="http://neurogami.com/code/10-minutes/v2/">here</a>, 
<br><br>

      <h3>Clean, Expressive Code with Minimal Scaffolding</h3>
      You now should have a better understanding of some of the features that make Ruby so special, namely:
      <ul>
        <li>Ruby is primarily an object-oriented language, where a key concept is objects responding to messages.</li>
        <li>Ruby uses strong, dynamic typing, where the notion of "type"
 is based on what an object can do more than on a particular class name 
or inheritance hierarchy. An object's behavior is not confined to a 
literal mapping of messages to methods, and behavior may be constructed 
dynamically at run time.</li>
        <li>Ruby classes are open; you are free to alter their behavior for what you deem appropriate for a given application.</li>
      </ul>
      <br><br>
      This combination of open classes and dynamic behavior enables you 
to write clean, expressive code with a minimum of boilerplate 
scaffolding. Ruby gets out of the way and lets you get coding.
      <br>
      <br>


      <div id="sidebar1" title="Instructions for Executing launcher.rb in Unix and Windows">
        <table cellspacing="0" cellpadding="5" border="0">
          <tbody><tr>
            <td class="whiteHeader">
              Sidebar 1. Instructions for Executing launcher.rb in Unix and Windows
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              On Unix systems you can set the file as executable and call it directly:
<pre><code>
$ chmod u+x launcher.rb
$ ./launcher.rb
</code></pre>
              <br>
              Windows users have a leg up here if they used the so-called <a href="http://rubyforge.org/projects/rubyinstaller/" target="new">One-Click Ruby Installer</a>.
 It takes a few more clicks than one, but in the end it sets up an 
association for .rb files. So a Windows user should be able to execute 
the app straight off as follows:
<pre><code>
C:\some\dir&gt; launcher.rb
</code></pre>
              <br>
              However, Windows users should also know that though they 
can launch a Ruby file by double clicking on it from the Windows file 
explorer, the results are fleeting: code will execute in a command 
shell, which will remain visible only so long as the application is 
running. For the sake of this demonstration, it's best to run the file 
from a command shell.
              <br>
            </td>
          </tr>
        </tbody></table>
        <a class="link-back" href="#ref1">Back to article</a>
      </div>

      <div id="sidebar2" title="Sidebar 2. Why You Add initialize Method When Passing Arguments to " new'="" method'="">

        <table cellspacing="0" cellpadding="5" border="0">
          <tbody><tr>
            <td class="whiteHeader">
              Sidebar 2. Why You Add initialize Method When Passing Arguments to 'new' Method
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              You're probably thinking, <i>why am I adding a method named "initialize" when I want to pass arguments to a method named "new"?</i>
 The reason has to do with how Ruby creates objects from classes. All 
classes (such as Launcher) inherit from the class Object, and part of 
the deal is that the objects they create have a default <span class="icode">initialize</span> method. When the class method <span class="icode">new</span> is called, it first allocates some resources for the desired object, and then invokes the fresh object's <span class="icode">initialize</span> method. If you wish to provide creation parameters via <span class="icode">new</span>, you must define your own <span class="icode">initialize</span> method to handle the arguments in the newly created instance.
            </td>
          </tr>
        </tbody></table>
        <a class="link-back" href="#ref2">Back to article</a>
      </div>
      <div id="sidebar3" title="Sidebar 3. A Few Words About Objects, Types, and Behavior">

        <table cellspacing="0" cellpadding="5" border="0">
          <tbody><tr>
            <td class="whiteHeader">
              Sidebar 3. A Few Words About Objects, Types, and Behavior
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              Ruby follows a message-passing model of object-oriented programming. When you see code like <code>foo.bar</code>, it means that the message "bar" is being passed to the object referenced by <span class="icode">foo</span>. Most of the time, that object will have a method <span class="icode">bar</span>, and when you see such code you may be tempted to think of it as calling <span class="icode">foo</span>'s <span class="icode">bar</span> method. However, while that is convenient (and common), it is important to know what's happening under the hood.
              <br><br>
              When an object receives a message, it first looks for a 
corresponding method. The search will work its way up the inheritance 
hierarchy*, starting with the object's own class, until it reaches the <span class="icode">Object</span> class. If no match is found, then the method <span class="icode">method_missing</span> is called. As you may have guessed, there's a default implementation of <span class="icode">method_missing</span>,
 and it does nothing more than raise an exception. But just as you were 
able to override the default definition of initialize, you also can 
alter <span class="icode">method_missing</span>. You are free to 
redefine it so your object might apply some smarts to handling arbitrary
 message requests, making it appear that the object implements many more
 methods than it actually does.
              <br><br>
              This flexibility is at the core of one of the most 
appealing aspects of Ruby, but it also points to an important aspect 
that may trouble some people. You've seen that you do not declare data 
types when creating variables or defining method argument lists. If you 
want to check data types, you can. Code <i>can</i> ask for an object's 
type, and act accordingly. For example, you may want to write a method 
that accepts either a file name (e.g., a <span class="icode">String</span> object ) or a file handle (e.g., a <span class="icode">File</span>
 object). But Ruby code rarely checks an object's type simply for 
defensive measures, refusing to continue unless given an object that 
asserts itself to be a certain type. Because classes and objects are 
mutable at run-time, the notion of type in Ruby is essentially defined 
as the <i>behavior</i> of an object at any given time. Type is defined 
by which methods an object responds to, not which class it comes from. 
As Rubyist Logan Capaldo once said, "In Ruby, no one cares who your 
parents were. All they care about is if you know what you are talking 
about."
              <br><br>
              The general term for this is <i>duck typing</i>, from the phrase, "If it walks like a duck and quacks like a duck, then it's a duck."
              <br><br>
              <hr>
              * Note: This is not quite true; inheritance is but one way
 an object can obtain some behavior. For a better explanation of how 
Ruby decides what to do when an object is given a message, watch Patrick
 Farley at MountainWest RubyConf 2008 explain <a href="http://mtnwestrubyconf2008.confreaks.com/11farley.html">Ruby internals</a>. 
              <br>In fact, watching this talk should be one of your next
 steps in learning Ruby; metaprogamming tends to have a weird, 
mysterious aura around it, as if it were only something for Ruby gurus. 
 Truth is, if you understand a few core properties of Ruby objects you 
too can be a metaprogramming master.
            </td>
          </tr>
        </tbody></table>

        <a class="link-back" href="#ref3">Back to article</a>

      </div>

      <div id="sidebar4" title="Sidebar 4. The Smarts Behind Launching Logic">

        <table cellspacing="0" cellpadding="5" border="0">
          <tbody><tr>
            <td class="whiteHeader">
              Sidebar 4. The Smarts Behind Launching Logic
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              Where you were mapping a file extension to a particular 
application name, you now want to add associations with Ruby code. 
Specifically, you want Ruby classes custom-coded for each type of file 
you want to process.
              <br><br>
              First, create a new Ruby source file named launcherx.rb (the x is for extended) in the directory as launcher.rb:
<pre><code>
#!/usr/bin/env ruby
# File launcherx.rb
require 'launcher'

class Launcher
  def handler file 
    get_handler(file) || build_handler(file)
  end
  
  def build_handler file 
    handler = Class.new 
    application = select_app file
    eval "def handler.run file,  args=nil
      system '#{application} \#{file} \#{args}'  
    end"
    handler
  end

  def get_handler file
    begin
      here = File.expand_path( File.dirname __FILE__  )
      ftype = file_type file
      require "#{here}/handlers/#{ftype }"
      Object.const_get( ftype.capitalize ).new
    rescue Exception
      nil
    end
  end

  # Execute the given file using he associate app
  def run file, args = nil 
    handler(file).run file, args
  end
end

</code></pre>
              <br><br>
              The first thing to note is that the code is calling <span class="icode">require</span>
 to load the existing definition of Launcher. Yet your new code also 
defines a class named Launcher. What gives? When Ruby encounters a class
 definition that uses the name of an existing class, it updates the 
existing class with the new class. The methods defined in your first 
version of Launcher are still there; new methods defined in the 
additional code get added. And, as in the case of <span class="icode">run</span>,
 when new code uses the same name as existing code, the new code 
replaces the old. The upshot of this is that you do not have to 
duplicate the code from your first version; you need only add to or 
modify it.
              <br><br>
              [EDIT: In going through the code I found that the original version of <span class="icode">build_handler</span>
 did not escape the use of string interpolation.  Here's what that 
means: Ruby allows you to create strings that contain evaluated bits of 
Ruby code. For example, "Today is #{Time.now}",  will, when evaluated by
 Ruby, contain the date at the time of execution.  The stuff inside of <span class="icode">#{ ... }</span> is first evaluated before being placed into the resulting string. <br><br>
              Now: Suppose you want to create a string that contains 
Ruby code that can be used (at a later date) for string interpolation? 
What <span class="icode">build_handler</span> is doing is dynamically 
generating code for a method to be used at some later time.  That code 
needs to contain some string interpolation.  The trick is to embed <span class="icode">#{ ... }</span>
 in such a way that it is not immediately evaluated (when we are first 
dynamically creating the method code).  The way to do that is to <em>escape</em> the leading hash character using a backslash: <span class="icode">\#{ ... }</span>.<br><br>
              The original version did not do this.  The code worked 
more or less coincidentally, given the artificial use-case for this 
article.  The first version ended up hard-coding specific values for <span class="icode">file</span> and <span class="icode">args</span>. 
              However, if <span class="icode">build_handler</span> is passed, for example, 'html', then the generated methods should be something like 

<pre>   def handler.run file,  args=nil
     system 'firefox  #{file} #{args}'  
   end
</pre>
      
              ]
              <br><br>
              Not so incidentally, this also works on core Ruby classes. For example, you can add to or alter the behavior of <span class="icode">String</span> by defining a <span class="icode">String</span>
 class with your own methods. If your code is frequently altering 
strings (perhaps to replace special characters), you can make your code 
clearer with something like this:
<pre><code>
class String
  def amp_escape
    self.gsub '&amp;', '&amp;amp;' 
  end
end

</code></pre>
              <br><br>
              Which then enables your code to do this:
<pre><code>
"This &amp; that".amp_escape
</code></pre>
              <br><br>
              Your new application file now needs to handle the new behavior. The <span class="icode">run</span>
 method changes because this new version will be invoking Ruby code 
instead of directly calling a shell command, and you want the option of 
passing in additional arguments. Therefore, this version expects a file 
name and an optional array of arguments. It's optional because in the 
methods argument list you're giving it a default value of nil. Arguments
 pre-assigned this way must always come last in the argument list.
              <br><br>
              Whereas your first version simply used the file extension to pull an application name from a hash, this code uses <span class="icode">handler</span> to create a corresponding Ruby class to handle the given file name. The <span class="icode">handler</span> method is short; it first calls <span class="icode">get_handler</span> to see if it can locate a matching handler class. The <span class="icode">||</span> method is Ruby's logical OR. Should <span class="icode">get_handler</span> return <span class="icode">false</span> (or <span class="icode">nil</span>, which Ruby treats as <span class="icode">false</span>), then the code to the right of <span class="icode">||</span> is invoked. If there is no defined handler class, then the code makes one.
              <br><br>
              Recall that your new version of <span class="icode">run</span> will expect <span class="icode">get_handler</span> to return an object that responds to the <span class="icode">run</span> message. The <span class="icode">build_handler</span>
 method therefore needs to define a class with this behavior. There are a
 variety of ways you could do this. Here, you're going to first create a
 generic instance of the class <span class="icode">Class</span> and then dynamically add a <span class="icode">run</span> method that knows how to handle the particular file type in question.
              <br><br>
              Your new Launcher class retained the application map code 
from the original. This mapping serves as a fallback for handling files 
in the absence of any special Ruby code, meaning that your new version 
still does what the first version did. Your code can still call <span class="icode">select_app</span> to get the default application. The trick now is to get that into a method on your new class.
              <br><br>
              Perhaps the simplest way to do this is to build a string with the code you might write if you <i>did</i> know which application to invoke. You then have Ruby <span class="icode">eval</span> (i.e., evaluate) this string, making it part of the current process. (Note: capricious use of <span class="icode">eval</span>
 on arbitrary strings is not wise. It works well for the sample 
application and helps demonstrate an interesting feature of Ruby, but 
use it with care in more serious applications--especially any code that 
allows input from users.)
              <br><br>
              Just like that, <span class="icode">build_handler</span> can now return an object (albeit sparse) that knows how to do the one thing that matters: respond to a <span class="icode">run</span> request.
              <br><br>
            </td>
          </tr>
        </tbody></table>
        <a class="link-back" href="#ref4">Back to article</a>
      </div>

      <div id="sidebar5" title="Sidebar 5. Dynamic Class Loading">
        <table cellspacing="0" cellpadding="5" width="510" border="0">
          <tbody><tr>
            <td class="whiteHeader">
              Sidebar 5. Dynamic Class Loading
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              The real fun is in defining custom Ruby classes that have more interesting implementations of <span class="icode">run</span>.
 First, assume all these classes will live in files named after the file
 extension they handle. For example, a handler class designed to process
 HTML files will go into a file named <span class="icode">html.rb</span>. Also, all such files will go into a relative subdirectory named <span class="icode">handlers</span>. Asserting these two conventions allows the <span class="icode">get_handler</span> code to know just what to look for and where to look for it, bypassing a need for lengthy configuration settings.
              <br><br>
              When <span class="icode">get_handler</span> is called, it:
              <ol>
                <li>Uses some built-in <span class="icode">File</span> methods to figure out the current file-path location (<span class="icode">__FILE__</span> is a special Ruby variable that refers to the actual file containing the current code).</li>
                <li>Appends your pre-defined handlers directory to the current path.</li>
                <li>Uses the file extension of the target file name to derive the name of the file holding the handler class code.</li>
              </ol>
              <br>
              All of this is passed to <span class="icode">require</span>
 with the expectation that such a file exists and that it will be 
loaded. If all goes well, Ruby will load and parse this file, making the
 desired class available to your code.
              <br><br>
              Now, without knowing the name of the class you want to 
instantiate in advance, you again need to do a bit of dynamic 
invocation. You could again use <span class="icode">eval</span>, but you can also reach into Ruby's list of constants (remember, classes are Ruby constants) and call <span class="icode">new</span>. Again, if all has gone well, <span class="icode">Object.const_get</span> will return the class desired, and <span class="icode">new</span> will then return an instance.
              <br><br>
              Should something go wrong (perhaps there is no such file 
to load, or the code in the file is malformed) and Ruby raises an 
exception, the code uses <span class="icode">rescue</span> to handle things. You could use <span class="icode">rescue</span>
 with more specific exceptions for more targeted error handling, but for
 the purposes of this example, you simply want to trap all exceptions 
and quietly return <span class="icode">nil</span>.
              <br><br>
              You may have noticed that <span class="icode">get_handler</span>
 does not explicitly specify which value to return. Indeed, none of your
 methods have done so. In Ruby, the return value of a method (with some 
exceptions) is the value of the last expression executed. <span class="icode">get_handler</span> has one top-level expression: <span class="icode">begin/rescue/end</span>. Its value will be either the value of the last expression in the <span class="icode">begin/rescue</span> section or the value created in <span class="icode">rescue/end</span>. Ruby does define <span class="icode">return</span>,
 which exits a method returning the provided value, but method flow 
control is sufficient to define an unambiguous return in most cases.
              <br>
            </td>
          </tr>
        </tbody></table>
        <a class="link-back" href="#ref5">Back to article</a>
      </div>
      
      <div id="d_isqus_thread"></div>


      <div class="clear"></div>
      <div class="grids">This article was originally published on <a href="http://www.devx.com/RubySpecialReport/Article/34502/1954">DevX.com</a></div>
    </div>


 
        <!-- %= render :partial => '/d i s q u s' % -->
      </div>
      <div class="gap">&nbsp;</div>
      <div class="footer grids">

<p><i>Hack your world. Feed your head. Live curious.</i></p>
  <p>
    <span class="heady1">Neurogami ®</span>
    <span class="dotty">⋅</span>
    <span class="heady2">Software, music, art. Purveyor of dance noise. Since 2001.</span></p>
  <p>
    info@neurogami.com <span class="dotty">⋅</span>&nbsp;(480) 236 4136 / (707) 70 Neuro &nbsp;<span class="dotty">⋅</span>&nbsp;© Neurogami </p>

  <p style="text-align:center" id="icon-row">
    
    <a href="https://www.youtube.com/user/neurogami"><img src="on_files/youtube.png" alt="Neurogami YouTube"></a>
    <span class="dotty">&nbsp;</span><a class="icon" href="https://github.com/Neurogami"><img src="on_files/github.png" alt="Neurogami GitHub"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://soundcloud.com/neurogami"><img src="on_files/soundcloud.png" alt="Neurogami Soundcloud"></a>
    <span class="dotty">&nbsp;</span><a class="icon" href="https://vimeo.com/neurogami"><img src="on_files/vimeo.png" alt="Neurogami Vimeo"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://plus.google.com/+Neurogami"><img src="on_files/gplus-red.png" alt="Neurogami G+"></a>  
    <!-- span class='dotty'>&#160;</span><a class='icon' href='http://plus.neurogami.com'><img src='/img/wg_flat_style_social_icons/gplus-red.png' alt='Neurogami G+'></a -->  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://pinterest.com/neurogami"><img src="on_files/pinterest.png" alt="Neurogami Pinterest"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://myspace.com/neurogami"><img src="on_files/myspace.png" alt="Neurogami MySpace"></a>  
    <!-- span class='dotty'>&#160;</span><a class='icon' href='http://grooveshark.com/#!/profile/Neurogami/26314787'><img src='/img/wg_flat_style_social_icons/grooveshark.png' alt='Neurogami Grooveshark'></a -->  
    <span class="dotty">&nbsp;</span><a class="icon" href="http://cafepress.com/neurogami"><img src="on_files/cafepress.png" alt="Neurogami Cafepress"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="http://instagram.com/neurogami"><img src="on_files/instagram.png" alt="Neurogami Instagram"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://facebook.com/neurogami"><img src="on_files/facebook.png" alt="Neurogami Facebook"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://ello.co/neurogami"><img src="on_files/ello36.png" alt="Neurogami Ello"></a>  
    <span class="dotty">&nbsp;</span><a class="icon" href="https://twitter.com/neurogami"><img src="on_files/twitter.png" alt="Neurogami Twitter"></a>  
  </p>

</div>

    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8070304-1', 'neurogami.com');
  ga('send', 'pageview');

</script>
     <script type="text/javascript" src="on_files/jquery_002.js"></script>

<script type="text/javascript">

  $( document ).ready( function() {
      var $body = $('body'); //Cache this for performance

      var setBodyScale = function() {
      var scaleSource = $body.width(),
      scaleFactor = 0.12,                     
      maxScale = 1200,
      minScale = 100; //Tweak these values to taste

      var fontSize = scaleSource * scaleFactor; //Multiply the width of the body by the scaling factor:

      if (fontSize > maxScale) fontSize = maxScale;
      if (fontSize < minScale) fontSize = minScale; //Enforce the minimum and maximums

      $('body').css('font-size', fontSize + '%');
      }

      $(window).resize(function(){
        setBodyScale();
        });

      //Fire it when the page first loads:
      setBodyScale();
  });

</script>
 
   
 



</body></html>